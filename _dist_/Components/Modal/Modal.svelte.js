/* src\Components\Modal\Modal.svelte generated by Svelte v3.31.2 */
import {
	SvelteComponent,
	add_render_callback,
	append,
	attr,
	check_outros,
	create_bidirectional_transition,
	create_slot,
	detach,
	element,
	empty,
	group_outros,
	init,
	insert,
	listen,
	noop,
	run_all,
	safe_not_equal,
	space,
	transition_in,
	transition_out,
	update_slot
} from "../../../_snowpack/pkg/svelte/internal.js";

import { scale } from "../../../_snowpack/pkg/svelte/transition.js";
const get_modal_content_slot_changes = dirty => ({});
const get_modal_content_slot_context = ctx => ({});

// (18:0) {#if isOpen}
function create_if_block(ctx) {
	let div6;
	let div5;
	let div1;
	let div0;
	let t0;
	let t1;
	let span;
	let t3;
	let div4;
	let div2;
	let t4;
	let div3;
	let button0;
	let t6;
	let button1;
	let div6_transition;
	let current;
	let mounted;
	let dispose;
	let if_block = /*options*/ ctx[1].closeOnEscapeKey && create_if_block_1(ctx);
	const modal_content_slot_template = /*#slots*/ ctx[5].modal_content;
	const modal_content_slot = create_slot(modal_content_slot_template, ctx, /*$$scope*/ ctx[4], get_modal_content_slot_context);
	const modal_content_slot_or_fallback = modal_content_slot || fallback_block(ctx);

	return {
		c() {
			div6 = element("div");
			div5 = element("div");
			div1 = element("div");
			div0 = element("div");
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			span = element("span");
			span.textContent = "â€‹";
			t3 = space();
			div4 = element("div");
			div2 = element("div");
			if (modal_content_slot_or_fallback) modal_content_slot_or_fallback.c();
			t4 = space();
			div3 = element("div");
			button0 = element("button");
			button0.textContent = "Cancel";
			t6 = space();
			button1 = element("button");
			button1.textContent = "Confirm";
			attr(div0, "class", "absolute inset-0 bg-gray-500 opacity-75");
			attr(div1, "class", "fixed inset-0 transition-opacity");
			attr(div1, "aria-hidden", "true");
			attr(span, "class", "hidden sm:inline-block sm:align-middle sm:h-screen");
			attr(span, "aria-hidden", "true");
			attr(div2, "class", "px-4");
			attr(button0, "type", "button");
			attr(button0, "class", "w-6/12 inline-flex justify-center rounded-md border border-transparent shadow-sm  py-2  text-base font-medium text-gray ");
			attr(button1, "type", "button");
			attr(button1, "class", "w-6/12 inline-flex justify-center rounded-md border border-transparent shadow-sm  py-2 bg-green-600 text-base font-medium text-white hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500");
			attr(div3, "class", "mt-5 sm:mt-6 flex justify-around");
			attr(div4, "class", "inline-block align-bottom bg-white rounded-lg pt-5 text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-xl sm:w-full");
			attr(div4, "role", "dialog");
			attr(div4, "aria-modal", "true");
			attr(div4, "aria-labelledby", "modal-headline");
			attr(div5, "class", "flex items-end justify-center min-h-screen pt-4 pb-20 text-center sm:block sm:p-0");
			attr(div6, "class", "fixed z-10 inset-0 overflow-y-auto");
		},
		m(target, anchor) {
			insert(target, div6, anchor);
			append(div6, div5);
			append(div5, div1);
			append(div1, div0);
			append(div1, t0);
			if (if_block) if_block.m(div1, null);
			append(div5, t1);
			append(div5, span);
			append(div5, t3);
			append(div5, div4);
			append(div4, div2);

			if (modal_content_slot_or_fallback) {
				modal_content_slot_or_fallback.m(div2, null);
			}

			append(div4, t4);
			append(div4, div3);
			append(div3, button0);
			append(div3, t6);
			append(div3, button1);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div0, "click", /*click_handler*/ ctx[7]),
					listen(button0, "click", /*closeModal*/ ctx[2])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*options*/ ctx[1].closeOnEscapeKey) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					if_block.m(div1, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (modal_content_slot) {
				if (modal_content_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(modal_content_slot, modal_content_slot_template, ctx, /*$$scope*/ ctx[4], dirty, get_modal_content_slot_changes, get_modal_content_slot_context);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(modal_content_slot_or_fallback, local);

			add_render_callback(() => {
				if (!div6_transition) div6_transition = create_bidirectional_transition(div6, scale, { duration: 200 }, true);
				div6_transition.run(1);
			});

			current = true;
		},
		o(local) {
			transition_out(modal_content_slot_or_fallback, local);
			if (!div6_transition) div6_transition = create_bidirectional_transition(div6, scale, { duration: 200 }, false);
			div6_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div6);
			if (if_block) if_block.d();
			if (modal_content_slot_or_fallback) modal_content_slot_or_fallback.d(detaching);
			if (detaching && div6_transition) div6_transition.end();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (32:8) {#if options.closeOnEscapeKey}
function create_if_block_1(ctx) {
	let span;
	let mounted;
	let dispose;

	return {
		c() {
			span = element("span");
			span.textContent = "Esc Key";
			attr(span, "class", "absolute top-0 right-0 text-white p-4");
		},
		m(target, anchor) {
			insert(target, span, anchor);

			if (!mounted) {
				dispose = listen(span, "click", /*closeModal*/ ctx[2]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(span);
			mounted = false;
			dispose();
		}
	};
}

// (50:37)               
function fallback_block(ctx) {
	let h1;

	return {
		c() {
			h1 = element("h1");
			h1.textContent = "Slot for your content";
			attr(h1, "class", "text-center");
		},
		m(target, anchor) {
			insert(target, h1, anchor);
		},
		d(detaching) {
			if (detaching) detach(h1);
		}
	};
}

function create_fragment(ctx) {
	let if_block_anchor;
	let current;
	let mounted;
	let dispose;
	let if_block = /*isOpen*/ ctx[0] && create_if_block(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(window, "keyup", /*keyup_handler*/ ctx[6]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*isOpen*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isOpen*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
			mounted = false;
			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	
	let { isOpen } = $$props;
	let { options } = $$props;

	const closeModal = () => {
		$$invalidate(0, isOpen = false);
	};

	const handleEscapeKey = ({ key }) => {
		if (key == "Escape") {
			$$invalidate(0, isOpen = false);
		}
	};

	const keyup_handler = e => options.closeOnEscapeKey ? handleEscapeKey(e) : null;
	const click_handler = () => options.closeOnBackgroundPress ? closeModal() : null;

	$$self.$$set = $$props => {
		if ("isOpen" in $$props) $$invalidate(0, isOpen = $$props.isOpen);
		if ("options" in $$props) $$invalidate(1, options = $$props.options);
		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
	};

	return [
		isOpen,
		options,
		closeModal,
		handleEscapeKey,
		$$scope,
		slots,
		keyup_handler,
		click_handler
	];
}

class Modal extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { isOpen: 0, options: 1 });
	}
}

export default Modal;